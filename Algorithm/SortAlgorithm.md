# 정렬알고리즘과 장단점

### 선택 정렬(Selection Sort)

> 선택 정렬은 앞쪽부터 정렬하는 방식이다. 주어진 배열에서 가장 작은 최소값을 찾고 배열의 맨 앞의 값과 위치를 바꾸면서 정렬한다. 선택 정렬은 배열의 최솟값을 찾아 선택하여 정렬한다는 뜻에서 이름이 붙여졌다. 배열에서 최솟값을 찾아야 하기 때문에 비교 횟수는 많지만 실제로 값을 바꾸는 교환 횟수가 적다는 것이 특징이다.

![](https://github.com/jj3031/TIL/blob/main/IMG/%ED%80%B5%EC%A0%95%EB%A0%AC.gif?raw=true)

### 장점
▶️ 구현이 간단하다.

▶️ 데이터를 하나씩 비교하기 때문에 정밀한 비교가 가능하다.

▶️ 비교하는 횟수에 비해 교환하는 횟수가 적다.

### 단점
▶️ 데이터를 하나씩 비교하기 때문에  시간이 오래 걸린다.

▶️ 정렬된 상태에서 새로운 데이터가 추가되면 정렬 효율이 좋지 않다.



### 버블 정렬(Bubble Sort)

> 버블 정렬은 첫번째 원소부터 인접한 원소와 비교하며 자리를 바꾸면서 맨 끝부터 정렬하는 방식이다. i번째 원소와 i+1번째 원소의 값을 비교하고 만약 i번째의 값이 i+1번째의 값보다 크다면 둘의 자리를 바꾸어 값이 큰 원소가 뒤에 위치하게 한다. 이를 반복해서 수행하면 가장 큰 값부터 뒤쪽에 쌓이게 된다. 즉 가장 큰값을 하나씩 뒤로 보내면서 뒤쪽부터 정렬한다. 버블 정렬은 정렬 방식이 마치 물속에서 올라오는 물방울과 같다고 하여 버블 정렬이라는 이름이 붙여졌다.

![](https://github.com/jj3031/TIL/blob/main/IMG/%ED%80%B5%EC%A0%95%EB%A0%AC.gif?raw=true)

### 장점
▶️ 구현이 간단하다.

▶️ 데이터를 하나씩 비교하기 때문에 정밀한 비교가 가능하다.

### 단점
▶️ 데이터를 하나씩 비교하기 때문에 비교 횟수가 많아지므로 시간이 오래 걸린다.



### 삽입 정렬(Insertion Sort)

> 삽입 정렬은 버블 정렬의 비효율성을 개선하기 위해 등장한 방법이다. 버블 정렬은 i번째와 i+1번째를 비교하며 위치를 바꾸었다면 삽입 정렬은 i번째 원소를 정렬된 상태의 앞부분과 비교하여 적절한 위치에 삽입하는 방식이다. i-1번째 원소까지는 모두 정렬된 상태여야 하며 i-1번째부터 0번째 원소와 i번째 원소를 각각 비교한다. 이때 i번째 원소보다 작은 값이 발견되면 그 위치에 i번째 원소를 삽입한다. 삽입 정렬은 버블 정렬의 비교 및 교환 횟수를 줄임으로써 높은 효율을 보여준다.

![](https://github.com/jj3031/TIL/blob/main/IMG/%ED%80%B5%EC%A0%95%EB%A0%AC.gif?raw=true)

### 장점
▶️ 입력으로 들어오는 배열의 원소가 정렬되어있을수록 속도가 빠르다.

▶️ 정렬된 값은 교환이 일어나지 않는다.

### 단점
▶️ 삽입을 구현해야 하므로 속도가 자료구조의 영향을 많이 받는다.

▶️ 입력으로 들어오는 배열이 역순으로 정렬된 경우 성능이 굉장히 좋지 않다.



### 병합 정렬(Merge Sort)

> 병합 정렬은 배열을 작은 단위로 쪼개어 정렬한 결과를 합치면서 전체를 정렬하는 방식이다. 배열을 왼쪽 절반, 오른쪽 절반으로 분할하여 최소 단위로 쪼갠 후 정렬을 진행한다. 대부분의 경우 병합 정렬은 상당한 안정성을 가지기 때문에 좋은 성능을 보인다. 하지만 작은 단위로 쪼갠 배열을 저장할 공간을 사용하기 때문에 추가적인 메모리가 필요하다.

![](https://github.com/jj3031/TIL/blob/main/IMG/%ED%80%B5%EC%A0%95%EB%A0%AC.gif?raw=true)

### 장점
▶️ 항상 일정한 시간 복잡도(O(NlogN))를 가진다.

▶️ 안정적이며 대부분의 경우에서 좋은 성능을 낸다.

### 단점
▶️ 추가 메모리 공간이 필요하다.



### 힙 정렬(Heap Sort)

> 힙 정렬은 최대 힙 트리(Max Heap Tree)나 최소 힙 트리(Min Heap Tree)를 구성하여 정렬하는 방식이다. 여기서 '힙(Heap)'이라는 자료구조가 사용되는데 힙은 완전 이진 트리의 일종으로 우선순위 큐를 위해 만들어진 자료구조이다. 여러 개의 값중에서 최댓값이나 최솟값을 빠르게 찾기 위해 사용된다. 최대 힙 트리는 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리이며 최소 힙 트리는 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리이다.

![](https://github.com/jj3031/TIL/blob/main/IMG/%ED%80%B5%EC%A0%95%EB%A0%AC.gif?raw=true)

### 장점
▶️ 항상 같은 시간 복잡도를 가지기 때문에 성능이 준수하다.

### 단점
▶️ 같은 시간 복잡도를 가지는 다른 정렬 알고리즘과 비교하면 느린 편이다.


### 셸 정렬(Shell Sort)

> 셸 정렬은 삽입 정렬의 문제점을 해결하기 위해 등장한 방법이다. 입력으로 들어온 배열을 간격(gap)이라고 하는 일정한 기준에 따라 분류한다. 이를 통해 연속적이지 않은 여러 개의 부분 배열을 생성한 후 각 배열을 삽입 정렬로 정렬한다. 모든 배열이 정렬되면 다시 전체 배열을 여러 개의 부분 배열로 나누는데 이때 간격을 전 단계보다 더 작게 설정하여 생성되는 부분 배열의 개수를 전 단계보다 적게 만든다. 그 후 부분 배열의 개수가 1이 될 때까지 앞의 과정을 반복한다.

![](https://github.com/jj3031/TIL/blob/main/IMG/%ED%80%B5%EC%A0%95%EB%A0%AC.gif?raw=true)

### 장점
▶️ 삽입 정렬의 문제점을 해결함으로써 성능이 좋다.

### 단점
▶️ 설정한 간격(gap)에 따라 성능의 차이가 심하다.



### 시간 복잡도 & 공간 복잡도

> 각 정렬 알고리즘의 시간 복잡도와 공간 복잡도는 아래와 같다.

![](https://github.com/jj3031/TIL/blob/main/IMG/%ED%80%B5%EC%A0%95%EB%A0%AC.gif?raw=true)



>아래 사이트에서 모든 정렬의 동작 과정을 확인할 수 있고 속도도 비교해볼 수 있다.
https://www.toptal.com/developers/sorting-algorithms


>참조 https://jbhs7014.tistory.com/180